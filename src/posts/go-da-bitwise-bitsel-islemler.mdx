---
title: Go'da Bitwise (Bitsel) Ä°ÅŸlemler
description: Bu yazÄ±da Go'da Bitwise iÅŸlemlerden ve operatÃ¶rlerden bahsettim.
date: '2023-09-24'
tags:
  - go
  - bitwise
  - bitsel
  - iÅŸlemler
  - operatÃ¶rler
published: true
---

Bitwise(Bitsel) iÅŸlemler yapabilmek iÃ§in Ã¶nce Bitwise operatÃ¶rleri bilmemiz gerekir.

Bitwise(Bitsel) OperatÃ¶rler ikili(binary) sayÄ±larÄ± karÅŸÄ±laÅŸtÄ±rmak iÃ§in kullanÄ±lÄ±r.

Anlam tablomuzu gÃ¶relim

| OperatÃ¶r          | AnlamÄ±                     |
|-------------------|----------------------------|
| `A&B`             | AND(VE)                    |
| `A&^B`            | AND NOT(VE DEÄÄ°L)          |
| `^B`              | NOT(DEÄÄ°L)                 |
| <code>A\|B</code> | OR(VEYA)                   |
| `A^B`             | XOR(Ã–ZEL VEYA)             |
| `A<<B`            | Left Shift(Sola KaydÄ±rma)  |
| `A>>B`            | Right Shift(SaÄŸa KaydÄ±rma) |

## & -AND(VE) OperatÃ¶rÃ¼

AnlaÅŸÄ±lÄ±r bir Ã¶rnek olmasÄ± iÃ§in 1 ve 0 sayÄ±larÄ±ndan Ã¶rnek gÃ¶relim.

![and-operatoru](/img/post-images/and_operator.webp)

Yani `A` ve`B` binary bitini `&` ile karÅŸÄ±laÅŸtÄ±rmamÄ±z basitÃ§e bu 2 biti birbiri ile binary biti olarak Ã§arpmamÄ±z anlamÄ±na geliyor.

Ã–rnek:

```go
fmt.Println(1&0) // 0
```

## &^ -AND NOT(VE DEÄÄ°L) OperatÃ¶rÃ¼

![and-not-operatoru](/img/post-images/and_not_operator.webp)

## | - OR (VEYA) OperatÃ¶rÃ¼

![or-operatoru](/img/post-images/or_operator.webp)

FarklÄ± ÅŸekilde dÃ¼ÅŸÃ¼nÃ¼rsek `A` ile `B`'nin toplamÄ± 0 deÄŸilse 1'dir. `A+B=C` formÃ¼lÃ¼ `A` ve `B`'nin 1 olduÄŸunu durumda 2 Ã§Ä±ktÄ±ÄŸÄ± iÃ§in doÄŸru bir Ã¶nerme deÄŸildir fakat `2` diye bir binary biti olmadÄ±ÄŸÄ± iÃ§in 1 olarak dÃ¼ÅŸÃ¼nebiliriz. Bu da farklÄ± bir akÄ±lda tutma yÃ¶ntemi olmakla beraber kullanÄ±p kullanmamak size kalmÄ±ÅŸ. Ne kadar doÄŸru olmasa da ğŸ˜

Ã–rnek:

```go
fmt.Println(1|0) // 1
```

## ^ - XOR (Ã–ZEL VEYA) OperatÃ¶rÃ¼

![xor-operatoru](/img/post-images/xor_operator.webp)

## ^ - NOT (DEÄÄ°L) OperatÃ¶rÃ¼

Bir de bu operatÃ¶rÃ¼n NOT iÅŸlemi iÃ§in kullanÄ±mÄ± vardÄ±r. XOR'dan yazÄ±m olarak farkÄ± sadece saÄŸ tarafÄ±nda deÄŸiÅŸken belirtilmesidir.

![not-operatoru](/img/post-images/not_operator.webp)

Ã–rnek:

```go
fmt.Println(1^0) // 1
```

Åuana kadar Ã¶ÄŸrendiÄŸimiz operatÃ¶rlere baktÄ±ÄŸÄ±mÄ±zda hep `0` ve `1` sayÄ±larÄ±nÄ± kullandÄ±k. Bunun sebebi `1` ve `0` sayÄ±larÄ±nÄ±n binary karÅŸÄ±lÄ±klarÄ± da `1` ve `0` olduÄŸu iÃ§indi.

### Ä°ÅŸlemler YapalÄ±m

`<<` ve `>>` operatÃ¶rÃ¼n kullanÄ±mÄ±na geÃ§meden Ã¶nce binary sistemi daha iyi anlamak iÃ§in Ã¶rnekler yapalÄ±m. `<<` ve `>>` (binary shifting) operatÃ¶rleri,  binary mantÄ±ÄŸÄ±nÄ± Ã¶ÄŸrendikÃ§e daha kolay gelecektir.

Ä°nsanlar gÃ¼nlÃ¼k hayatÄ±nda 10'luk _(decimal veya 10 tabanÄ±)_ sayÄ± sistemini kullanÄ±r. Yani 0-9 arasÄ± rakamlarÄ± kullanarak sayÄ±lar Ã¼retiriz. Toplamda 10 adet rakam olduÄŸu iÃ§in 10'luk _(decimal)_ sayÄ± sistemi denir.

Fakat yukarÄ±daki Ã¶rnekler 2'li _(binary veya 2 tabanÄ±)_ sayÄ± sistemini kapsar. Ã‡Ã¼nkÃ¼ 1 ve 0'dan ibarettirler. Bitwise operatÃ¶rleri de binary sistemi baz alarak karÅŸÄ±laÅŸtÄ±rma yapar.

!> Bu yazÄ±mÄ±zda sadece sayÄ±sal olarak gerÃ§ekleÅŸtirilen iÅŸlemlerden bahsedeceÄŸim. Ã‡Ã¼nkÃ¼ konu yeterince uzun olacak. Daha fazla uzatmayalÄ±m.

#### Decimal'i Binary'e Ã‡evirme

```go
sayi := int64(13)

fmt.Println(strconv.FormatInt(sayi, 2)) // 1101
```

`strconv` paketindeki `FormatInt()` fonksiyonu ilk parametresinde `int64` tipinde deÄŸer alÄ±r, ikinci parametresinde ise hangi sayÄ± sistemine dÃ¶nÃ¼ÅŸtÃ¼rmek istiyorsak onu belirtiriz. Bizim durumumuzda `binary` istediÄŸimiz iÃ§in `2` yazdÄ±k.

Yani yukarÄ±da `13` decimal sayÄ±sÄ±nÄ± binary formatÄ±nda `1101`'a dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼k.

Bunun iÃ§in `fmt` paketini de kullanabiliriz.

```go
var x uint8 = 13
fmt.Printf("%b \n", x) //1101
```

GÃ¶stericeÄŸimiz deÄŸiÅŸkenin, kaÃ§ adet bitini gÃ¶stereceÄŸimizi de belirleyelim.

```go
var x uint8 = 13
fmt.Printf("%08b \n", x) //00001101
```

`uint8` tipinde bir deÄŸiÅŸken en fazla 8 bitlik deÄŸer taÅŸÄ±yabileceÄŸinden 8'den fazlasÄ±nÄ± gÃ¶stermeye gerek yoktur. Format karakterinin baÅŸÄ±ndaki sÄ±fÄ±r ise sol taraftaki boÅŸ bitlerin yerine 0 gÃ¶sterilmesini saÄŸlar. Bu deÄŸeri bir deÄŸiÅŸkene `string` olarak atamak isteseydik aÅŸaÄŸÄ±daki gibi yapabilirdik.

```go
var xDecimal uint8 = 7
var xBinary string = fmt.Sprintf("%08b", xDecimal)
fmt.Println(xBinary) //00000111
```

AramÄ±zda hangi mantÄ±k ile dÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼ÄŸÃ¼nÃ¼ Ã¶ÄŸrenmek isteyenler olabilir. Onlar iÃ§in gÃ¶relim.

![dec-to-bin](/img/post-images/dec_to_bin.webp)

NasÄ±l dÃ¶nÃ¼ÅŸtÃ¼rme yaptÄ±ÄŸÄ±mÄ±zÄ±n mantÄ±ÄŸÄ±nÄ± Ã¶ÄŸrendiÄŸimize gÃ¶re kendimiz de bunun iÃ§in bir fonksiyon Ã¼retebiliriz.

```go
func main() {
	fmt.Println("sonuÃ§:", intToBinaryString(34))
}

func intToBinaryString(decimal int) (binary string) {
	if decimal < 0 {
		// negatif olduÄŸu iÃ§in binary deÄŸerin
		// eksi ile baÅŸlamasÄ± gerekir.
		binary = "-"

		// BÃ¶lme iÅŸleminde pozitif sonuÃ§ almak iÃ§in
		// negatif ise pozitife Ã§eviriyoruz.
		decimal = -decimal // -decimal * -1 = +decimal
	}

	if decimal < 2 {
		// Decimal sayÄ±mÄ±z 0 veya 1 ise bÃ¶lme iÅŸlemi
		// yapmadan sonuÃ§ verdik.
		binary = fmt.Sprintf("%s%d", binary, decimal)
		return
	}

	for {
		if decimal < 2 {
			// 2'den kÃ¼Ã§Ã¼k sayÄ±lar 2 ye bÃ¶lÃ¼nemeyeceÄŸi iÃ§in
			// direkt olarak son bÃ¶lÃ¼mÃ¼ verip dÃ¶ndÃ¼yÃ¼ sonlardÄ±rÄ±yoruz.
			binary = fmt.Sprintf("%d%s", 1, binary)
			break
		}

		// Elle yaptÄ±ÄŸÄ±mÄ±z iÅŸlemdeki gibi sonucu ters Ã§evirmek yerine
		// direkt olarak ters ekleme yapÄ±yoruz.
		binary = fmt.Sprintf("%d%s", decimal%2, binary)
		decimal = decimal / 2

		// Her bÃ¶lmedeki Ã§Ä±kan biti gÃ¶relim.
		fmt.Println(binary)
	}

	return
}
```

Ã‡Ä±ktÄ±mÄ±z aÅŸaÄŸÄ±daki gibi olacaktÄ±r:

```text Ã‡Ä±ktÄ±
0
10
010
0010
00010
sonuÃ§: 100010
```

#### Binary'i Decimal'e Ã‡evirme

```go
sayi, err := strconv.ParseInt("111", 2, 64)
if err != nil {
	fmt.Println(err)
}
fmt.Println(sayi) // 7
```

YukarÄ±da `binary string`'imizi `int64`'e Ã§evirmek iÃ§in `strconv` paketinin `ParseInt()` fonksiyonunu kullandÄ±k.

Ä°lk parametresine `string` tipinde `binary` sayÄ±mÄ±zÄ± verdik. Ä°kinci parametremizde ilk parametremize binary sayÄ± verdiÄŸimiz iÃ§in 2 verdik. ÃœÃ§Ã¼ncÃ¼ parametremiz ise bizim bit uzunluÄŸumuz yani sayÄ±mÄ±zda kaÃ§ tane bit olacaÄŸÄ±dÄ±r. Minimum 0  , maksimum 64 deÄŸerini alabilir. Ã–rneÄŸimizin baÅŸarÄ±lÄ± bir ÅŸekilde Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶rebiliriz.

YukarÄ±daki Ã¶rneÄŸimizde bit uzunluÄŸumuza `64` deÄŸerini verdik. Peki zaten fonksiyonun dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ tip `int64` ise biz neden burada bit uzunluÄŸunu belirttik?

Ben merak ettiÄŸim iÃ§in bu fonksiyonun yazÄ±mÄ±nÄ± inceledim. 64 bit uzunluÄŸu verildiÄŸinde aslÄ±nda 63 biti parse ettiÄŸini gÃ¶rdÃ¼m. Bu da fonksiyon iÃ§erisinde `bitSize - 1` ÅŸeklinde belirtilmiÅŸ. Ve bu kullanÄ±m ile maksimum bulunacak sonucu aÅŸÄ±p aÅŸmadÄ±ÄŸÄ± kontrol ediliyor.

64 bit iÃ§erisindeki en solda bulunan bitimiz, sayÄ±nÄ±n artÄ± veya eksi yÃ¶nde olup olmadÄ±ÄŸÄ±nÄ±n bilgisini taÅŸÄ±r. AslÄ±nda sayÄ±mÄ±zÄ±n yÃ¶nsÃ¼z olarak deÄŸeri saÄŸdan 63 bit iÃ§erisinde taÅŸÄ±nÄ±r.

Bu mantÄ±k kullandÄ±ÄŸÄ±mÄ±z fonksiyonda bu ÅŸekilde kullanÄ±lmÄ±ÅŸ.

Bu bilgiden sonra alakalÄ± olarak bir Ã¶rnek gÃ¶relim.

```go
strconv.ParseInt("111", 2, 4)
```

YukarÄ±da decimal karÅŸÄ±lÄ±ÄŸÄ± `7` olan `111` binary sayÄ±sÄ±nÄ±n dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemi yapÄ±lmÄ±ÅŸtÄ±r.

Burada bit boyutunun `4` verilmesinin sebebi `+111` ÅŸeklinde deÄŸerlendirilecek olmasÄ± ve bu ÅŸekilde deÄŸerlendirildiÄŸinde `4` hane iÃ§ermesidir.

```go
strconv.ParseInt("-111", 2, 4)
```

`-111` ÅŸeklinde verildiÄŸinde ise aynÄ± ÅŸekilde `4` bit uzunluÄŸundadÄ±r ve sonucumuz `-7` Ã§Ä±kacaktÄ±r.

Daha fazla detaylarÄ± kurcalamak isteyenler incelemeye devam edebilir. Konuyu uzatmamak iÃ§in geÃ§iyorum.

#### Peki kendimiz Binary deÄŸeri, Decimal deÄŸere nasÄ±l Ã§eviririz?

![bin-to-dec](/img/post-images/bin_to_dec.webp)

!> Binary sayÄ±larda, decimal sayÄ±lardaki gibi sol tarafdaki basamak veya basamaklarÄ±n 0 olmasÄ± sayÄ±ya deÄŸer katmaz. `0101 = 101`

Madem bu iÅŸlemin de nasÄ±l yapÄ±ldÄ±ÄŸÄ±nÄ± Ã¶ÄŸrendiysek, kendimiz bir fonksiyon yazacak olsaydÄ±k nasÄ±l yapacaÄŸÄ±mÄ±za bakalÄ±m:

_(AslÄ±nda kodumuz basit fakat yorum satÄ±rlarÄ±ndan dolayÄ± karmaÅŸÄ±k duruyor ğŸ‘)_

```go
package main

import (
	"errors"
	"fmt"
	"math"
	"regexp"
	"strings"
)

func main() {
	decimal, err := binaryToDecimal("-10110")
	if err != nil {
		panic(err)
	}
	fmt.Println("sonucumuz:", decimal)
}

func binaryToDecimal(binary string) (int, error) {
	isNegative := false
	var result int

	// sadece -, 0 ve 1 karakterlerini iÃ§ermesi gerekiyor.
	// + karakteri gerekli deÄŸil.
	r, _ := regexp.Compile("^\\-?[0-1]+$")
	if !r.MatchString(binary) {
		return 0, errors.New("Sadece -, 0 ve 1 karakterlerini iÃ§erebilir.")
	}

	// binary eksi ile baÅŸlÄ±yorsa negatif
	// olarak yorumlandÄ±racaÄŸÄ±z
	if strings.HasPrefix(binary, "-") {
		isNegative = true
		// for dÃ¶ngÃ¼sÃ¼nde sadece bitleri kullanacaÄŸÄ±mÄ±z iÃ§in
		// baÅŸtaki eksiyi kaldÄ±rÄ±yoruz.
		binary = binary[1:]
	}

	for i, v := range binary {
		// rune tipinde gelen sayÄ±yÄ± int'e Ã§evirelim
		bit := int(v - '0')

		// Ä°ÅŸlemimiz = 2 Ã¼zeri (saÄŸdan sola index numarasÄ±) Ã§arpÄ± bit rakamÄ±
		result += int(math.Pow(2, float64(len(binary)-i-1))) * bit

		// index numarasÄ±nÄ± ters Ã§evirmek iÃ§in
		// len(binary)-i-1 kullandÄ±k.

	}

	// son olarak eksi deÄŸer ise artÄ±yÄ± eksiye Ã§eviriyoruz.
	if isNegative {
		result = -result
	}

	return result, nil
}
```

Decimal ve Binary arasÄ±ndaki dÃ¶nÃ¼ÅŸtÃ¼rme mevzusunu anladÄ±ÄŸÄ±mÄ±za gÃ¶re OR karÅŸÄ±laÅŸtÄ±rmasÄ±na geri dÃ¶nelim.

Bitwise karÅŸÄ±laÅŸtÄ±rmalarÄ±nda, verilen iki deÄŸer de `binary` sisteme dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼p karÅŸÄ±laÅŸtÄ±rma iÅŸlemi yapÄ±lÄ±r.

Yani `13 | 7` karÅŸÄ±laÅŸtÄ±rmasÄ± yapÄ±ldÄ±ÄŸÄ±nda aslÄ±nda `1101` ve `111` binary sayÄ±larÄ±nÄ± OR mantÄ±ÄŸÄ± ile karÅŸÄ±laÅŸtÄ±rÄ±yor.

Ã–rneÄŸimizi gÃ¶relim:

```go
fmt.Println(13 | 7) // 15
```

`OR` operatÃ¶rÃ¼nÃ¼ anlattÄ±ÄŸÄ±m bÃ¶lÃ¼mde bitleri karÅŸÄ±laÅŸtÄ±rÄ±p ne sonuÃ§ verdiklerini gÃ¶rdÃ¼k. AslÄ±nda mantÄ±ken `if-else`'de kullandÄ±ÄŸÄ±mÄ±z `||` operatÃ¶rÃ¼ ile aynÄ± natÄ±k ile Ã§alÄ±ÅŸÄ±r.

Åimdi arkaplanda gerÃ§ekleÅŸen olaya bakalÄ±m. Yani `13 | 7` karÅŸÄ±laÅŸtÄ±rmasÄ±nda `15` nasÄ±l bulunduÄŸuna.

`13` ve `7` decimal sayÄ±larÄ±nÄ±n binary karÅŸÄ±lÄ±klarÄ±nÄ± `OR` mantÄ±ÄŸÄ± ile karÅŸÄ±laÅŸtÄ±rmak iÃ§in basamak uzunluÄŸunu eÅŸitleyelim.

![or-example](/img/post-images/or_example.webp)


`&` operatÃ¶rÃ¼nÃ¼ incelemek iÃ§in `13&7` iÅŸleminin sonucuna bakalÄ±m.

```go
fmt.Println(13 & 7) // 5
```

Bu iÅŸlemde `5` sonucunun nasÄ±l bulunduÄŸuna bakalÄ±m.

![and-example](/img/post-images/and_example.webp)

Bir de `^` - XOR (Ã–ZEL VEYA) iÃ§in olan Ã¶rneÄŸimizi gÃ¶relim.

Ä°ÅŸlemimiz `13^7` olacak. SÃ¼rekli decimal'i binary'e dÃ¶nÃ¼ÅŸtÃ¼rmemek iÃ§in aynÄ± sayÄ±lar Ã¼zerinden Ã¶rnek verdim

```go
fmt.Println(13 ^ 7) // 10
```

NasÄ±l `10` sonucunun bulunduÄŸuna bakalÄ±m.

![xor-example](/img/post-images/xor_example.webp)

Ã–rneklerimizde `or`, `and` ve `xor` operatÃ¶rlerinin kullanÄ±mlarÄ±nÄ± ve arkaplanda ne iÅŸlemler gerÃ§ekleÅŸtiÄŸini gÃ¶rdÃ¼k. Bu iÅŸlemlerimizde sÃ¶z konusu olan bit rakamlarÄ±nÄ±n karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± ve buna gÃ¶re sonuÃ§ Ã¼retilmesiydi. SÄ±ra geldi shift iÃ§in kullandÄ±ÄŸÄ±mÄ±z operatÃ¶rlere.

## `<<` - Shift Left (Sola KaydÄ±rma) OperatÃ¶rÃ¼
AdÄ±ndan da anlaÅŸÄ±labileceÄŸi Ã¼zere bitleri sola kaydÄ±rÄ±r. DiÄŸer tÃ¼rlÃ¼ dÃ¼ÅŸÃ¼nÃ¼rsek bitlerin saÄŸÄ±na sÄ±fÄ±r ekler.
Ã–rnek kullanÄ±mÄ±:

```go
fmt.Println(7 << 6) // 448
```
Sonucun nasÄ±l `448` Ã§Ä±ktÄ±ÄŸÄ±na bakalÄ±m.
`7`'nin binary karÅŸÄ±lÄ±ÄŸÄ± `111` ÅŸeklindedir. `111` binary sayÄ±sÄ±nÄ±n saÄŸ tarafÄ±na `6` tane sÄ±fÄ±r eklediÄŸimizde `111000000` sayÄ±sÄ± Ã§Ä±kar. Daha okunaklÄ± olmasÄ± iÃ§in `4`'er basamak ÅŸeklinde ayÄ±rabiliriz.

`0001 1100 0000` ÅŸeklinde daha az gÃ¶z yorucu olur.

Bu sayÄ±yÄ± da decimal'e Ã§evirdiÄŸimizde `448` sayÄ±sÄ±nÄ± elde ederiz.

PekiÅŸtirmek istersek ÅŸunlarÄ± da yapabiliriz.

```go
x := 7              // (0111)
fmt.Println(x << 1) // (1110) => 14
fmt.Println(x << 4) // (0111 0000) => 112
fmt.Println(x << 6) // (0001 1100 0000) => 448
```

### Veri tipi detaylarÄ±na inelim

YukarÄ±da bit kaydÄ±rma iÅŸlemleri yaptÄ±k. `x` deÄŸiÅŸkenimize `:=` ile kÄ±sa tanÄ±mlama yaptÄ±ÄŸÄ±mÄ±z iÃ§in derleyicimiz `7` sayÄ±sÄ±nÄ± `int` tipi olarak belirleyecektir.

AslÄ±na bakarsak `int` tipi demek, 64bit sistemlerde `int64`, 32bit sistemlerde ise `int32` olduÄŸu anlamÄ±na gelir. Yani `int`'in saklayabildiÄŸi bit boyutu (veya uzunluÄŸu) Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÅŸletim sisteminin mimarisine baÄŸlÄ±dÄ±r.

### Peki Bitwise Shifting iÅŸleminde bu konu bizi neden ilgilendiriyor?

Basit olarak bahsetmek istediÄŸim iÃ§in Ã¶rneÄŸimizi `uint8` Ã¼zerinden verelim. _(Åimdi artÄ±lar eksiler birbirine karÄ±ÅŸmasÄ±n ğŸ˜)_ `uint8` tipinde bir sayÄ±nÄ±n bit boyutu adÄ±ndan da anlaÅŸÄ±lacaÄŸÄ± Ã¼zere `8`'dir. `uint8`, unassigned (iÅŸaretsiz) integer olduÄŸu iÃ§in pozitif veya negatif sayÄ± iÃ§ermez. Yani dÃ¼mdÃ¼z sayÄ± saklar.

SaklayabileceÄŸi sayÄ± aralÄ±ÄŸÄ±, en fazla 2 Ã¼zeri 8' den 256'dÄ±r. Bu aralÄ±ÄŸa sÄ±fÄ±r da dahil olduÄŸu iÃ§in 0-255 arasÄ± deÄŸer alabilir. Binary olarak baktÄ±ÄŸÄ±mÄ±zda `00000000` ve `11111111` aralÄ±ÄŸÄ±nda binary deÄŸer taÅŸÄ±yabilir.

Left Shifting (sola kaydÄ±rma) yaptÄ±ÄŸÄ±mÄ±zda bitleri saÄŸdan sola doÄŸru iterek saÄŸa `0` eklemiÅŸ oluyoruz.

Bu durumda da fazla sola kaydÄ±rdÄ±ÄŸÄ±mÄ±zda soldaki bitlerimiz dÄ±ÅŸarÄ± taÅŸmÄ±ÅŸ oluyor ve taÅŸan bitlerimiz veri tipimizin boyutundan dolayÄ± saklanamÄ±yor.
Bir Ã¶rnek gÃ¶relim.

```go
var x uint8 = 7 // binary = 0000 0111
x = x << 6
// x'in binary karÅŸÄ±lÄ±ÄŸÄ±
// 0001 1100 0000 olmasÄ± beklenirken
// uint8 tipi 8 bit saklayabildiÄŸi iÃ§in
// saÄŸdan 8 bitin solundaki bitler dÄ±ÅŸarÄ± taÅŸtÄ±
// yani saklanmadÄ±
fmt.Printf("%08b %d \n", x, x) //11000000 192
// Bu yÃ¼zden deÄŸerimiz 448 yerine 192 olduo
```

![left-shift](/img/post-images/left_shift.webp)

## `>>` - Shift Right (SaÄŸa kaydÄ±r)

Bu iÅŸlemde sola kaydÄ±rmanÄ±n tam tersini yapÄ±yor. Yani bitleri saÄŸa doÄŸru itip boÅŸ kalan yerleri sÄ±fÄ±r ile dolduruyor olarak dÃ¼ÅŸÃ¼nebiliriz. AynÄ± ÅŸekilde veri tipinin boyutuna etki eden nedenlerdendir.

```go
var x uint8 = 7 // binary = 0000 0111
x = x >> 1
fmt.Printf("%08b %d \n", x, x) // 00000011 3
```

![right-shift](/img/post-images/right_shift.webp)

OkuduÄŸunuz iÃ§in teÅŸekkÃ¼rler. UmarÄ±m bir faydasÄ± dokunmuÅŸtur.
